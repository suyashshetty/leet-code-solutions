| **Optimization Technique**               | **Scenario**                                                                                     | **Solution/Approach**                                                                                                                                                                                                                                  |
|------------------------------------------|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **2D Prefix Sum Matrix**                 | Repeated queries for submatrix sums in a static 2D array.                                         | Precompute a 2D prefix sum matrix in O(n*m) time, enabling any submatrix sum to be answered in O(1) time by using inclusion-exclusion on the precomputed sums.                                                                                         |
| **Binary Lifting for LCA**               | Lowest Common Ancestor queries in trees for repeated queries.                                    | Precompute parent pointers for each node at increasing powers of two. This enables LCA queries to be answered in O(log n) time after O(n log n) preprocessing, making it highly efficient for tree-based queries.                             |
| **Difference Array**                     | Efficiently performing range update operations on an array with subsequent queries.               | Construct a difference array to convert range updates into constant-time operations, then compute the final values via a prefix sum. This technique minimizes per-update overhead and supports fast queries.                                         |
| **Disjoint Sparse Table**                | Range queries on arrays for associative operations where standard sparse tables may fail (e.g., non-idempotent operations). | Precompute answers for disjoint segments, allowing O(1) query time. This technique is especially useful when the operation does not satisfy idempotence, and it complements traditional sparse tables.                                         |
| **Fenwick Trees (Binary Indexed Trees)** | Handling dynamic prefix sum queries and point updates on large arrays.                            | Build a Fenwick Tree to precompute cumulative frequencies, allowing both prefix queries and point updates in O(log n) time. This is especially useful when updates and queries are interleaved.                                                      |
| **Precomputed Factorials and Inverses**  | Repeated combinatorial queries such as computing binomial coefficients (nCr) modulo a prime.         | Precompute factorials and their modular inverses in O(n) time. With these tables, each combination query can be answered in O(1) time, which is essential for problems involving many combinatorial queries.                                   |
| **Precomputed Hashing**                  | Fast substring comparisons and pattern matching in strings via repeated queries.                  | Precompute hash values for each prefix of a string. Then, using modular arithmetic, compute the hash of any substring in O(1) time, enabling rapid equality checks and pattern matching.                                                              |
| **Prefix Sum Array**                     | Repeated range sum queries on a static array.                                                     | Precompute a prefix sum array in O(n) time so that any query for the sum of elements in a range can be answered in O(1) time by subtracting the appropriate prefix sums.                                                                              |
| **Segment Trees**                        | Repeated range queries (e.g., sum, minimum, maximum) and dynamic updates on arrays.               | Build a segment tree in O(n) time that supports both queries and updates in O(log n) time, making it ideal for problems where the underlying data may change over time.                                                                             |
| **Sparse Table**                         | Static range queries for idempotent operations (e.g., minimum, maximum, gcd) on an array.         | Precompute a sparse table in O(n log n) time, which allows any range query to be answered in O(1) time. This technique is optimal when the array does not change after preprocessing.                                                              |
| **Square Root Decomposition**            | Repeated range queries and updates on arrays when a simpler, less complex implementation is acceptable. | Partition the array into blocks of size approximately √n and precompute aggregate information (such as sums or minima) for each block. This approach allows queries and updates to be processed in roughly O(√n) time.                     |
