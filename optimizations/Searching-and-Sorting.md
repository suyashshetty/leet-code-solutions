| **Optimization Technique**              | **Scenario**                                                                | **Solution/Approach**                                                                                                                                                  |
|-----------------------------------------|-----------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Binary Search**                       | Searching in sorted arrays or lists for a target value.                     | Use binary search to halve the search space with each iteration, achieving O(log n) time complexity.                                                                    |
| **Exponential Search**                  | Searching in unbounded or unknown-sized sorted arrays.                      | Start with a small interval and exponentially increase the range until the target is bounded, then perform binary search, yielding O(log n) complexity.             |
| **Interpolation Search**                | Searching in uniformly distributed sorted arrays.                           | Estimate the probable position of the target using linear interpolation, which can lead to an average-case time of O(log log n), though worst-case can degrade to O(n).|
| **Ternary Search**                      | Finding the maximum or minimum of a unimodal function.                      | Divide the search range into three segments and discard the segment that cannot contain the optimum, achieving O(log n) time for unimodal optimization problems.     |
| **Quickselect**                         | Finding the kth smallest (or largest) element in an unsorted array.           | Use a partition-based approach (similar to QuickSort) that recurses only into the part containing the kth element, with an average-case time of O(n).                  |
| **Counting Sort / Bucket Sort**         | Sorting integers or elements with a limited range of values.                 | Utilize auxiliary arrays (or buckets) to count or distribute elements, enabling linear O(n) time sorting when the value range is restricted.                         |
| **Radix Sort**                          | Sorting large numbers or strings where comparison-based sorts may be too slow.| Process elements digit-by-digit (or character-by-character) in a fixed base; this results in O(d*(n+b)) time complexity, where d is the number of digits and b the base.|
| **Optimized QuickSort**                 | General-purpose sorting with average-case O(n log n) performance.             | Enhance QuickSort by using randomized or median-of-three pivot selection to avoid worst-case O(nÂ²) scenarios and switch to insertion sort for small subarrays.      |
| **Heap Sort**                           | Sorting with guaranteed O(n log n) worst-case performance.                    | Build a heap from the input data and repeatedly extract the root to produce a sorted order, all while using in-place operations and O(n log n) time.                   |
| **Binary Search on Answer**             | Optimization problems where the solution lies within a numerical range.       | Combine binary search with a feasibility check on candidate answers to iteratively narrow down the optimal solution.                                                    |
| **Order Statistics Tree**               | Dynamic queries for the kth smallest or largest element in a mutable dataset. | Augment a balanced binary search tree with subtree sizes to support insertions, deletions, and kth-element queries all in O(log n) time.                              |
