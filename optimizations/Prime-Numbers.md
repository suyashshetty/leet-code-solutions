| **Optimization Technique**                        | **Scenario**                                                                                     | **Solution/Approach**                                                                                                                                                                                                                                                                                                                                                                  |
|---------------------------------------------------|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **AKS Primality Test**                            | Deterministic polynomial-time primality testing for numbers.                                     | Use the AKS algorithm to deterministically test whether a number is prime in polynomial time. Although it has higher constant factors compared to probabilistic methods, it guarantees correctness without errors.                                                                                                                                                           |
| **Chinese Remainder Theorem (CRT)**               | Solving simultaneous congruences with prime moduli.                                              | Combine remainders from different moduli to reconstruct a unique solution modulo the product of the moduli. This technique is especially useful when the moduli are pairwise coprime, often being primes.                                                                                                                                                                 |
| **Euler's Totient Function via Sieve**            | Computing the number of integers coprime to n, useful in modular arithmetic and inverses.           | Precompute φ(n) for all numbers up to a given limit using a modified sieve. The totient values can then be used to compute modular inverses or solve problems based on Euler's theorem efficiently.                                                                                                                                                                      |
| **Fermat's Little Theorem**                        | Fast computation of modular inverses and exponentiation under a prime modulus.                    | For a prime p and integer a not divisible by p, leverage the fact that a^(p-1) ≡ 1 (mod p) to compute the modular inverse as a^(p-2) mod p. This theorem also facilitates fast exponentiation under prime moduli in many competitive problems.                                                                                                                     |
| **Linear Sieve (Euler's Sieve)**                  | Generating all primes up to n in linear time and precomputing smallest prime factors.             | Implement a linear sieve to generate primes in O(n) time while also calculating the smallest prime factor (SPF) for each number. This is beneficial for rapid factorization queries and numerous number theory problems.                                                                                                                                                  |
| **Miller-Rabin Primality Test**                   | Probabilistic testing of large numbers for primality.                                            | Use the Miller-Rabin algorithm with a fixed number of iterations to probabilistically determine whether a number is prime. This method provides high accuracy and is often used when deterministic tests are too slow.                                                                                                                                                         |
| **Modular Exponentiation**                        | Efficiently computing large exponentiations under a modulus (i.e., a^b mod m).                     | Use exponentiation by squaring to reduce the number of multiplications, achieving O(log b) time complexity. This is crucial in cryptographic applications and competitive programming problems involving large exponents.                                                                                                                                                    |
| **Möbius Function Sieve**                         | Precomputation of the Möbius function for advanced number theory and inclusion-exclusion problems. | Use a sieve-based approach to calculate the Möbius function μ(n) for all numbers up to a given limit. The precomputed values are useful in problems involving summation over divisors and other multiplicative function properties.                                                                                                                                         |
| **Pollard's Rho Factorization**                   | Factorizing large composite numbers when trial division is inefficient.                          | Employ Pollard's Rho algorithm, a probabilistic method that efficiently finds a non-trivial factor of a composite number, reducing factorization time significantly compared to naive methods.                                                                                                                                                                           |
| **Prime Counting Function (Legendre's Formula)** | Estimating or computing the number of primes less than or equal to a given number n.              | Use Legendre's formula (or related advanced methods) to calculate π(n), the number of primes ≤ n. This technique is beneficial for problems involving the distribution of primes or estimating prime density.                                                                                                                                                            |
| **Segmented Sieve**                               | Generating primes within a large interval where a standard sieve would be memory-prohibitive.      | Divide the large interval into smaller segments and use precomputed primes (from a standard sieve) to mark non-prime numbers in each segment. This method reduces memory usage while efficiently generating primes over a large range.                                                                                                                                    |
| **Sieve of Atkin**                                | Generating all prime numbers up to a very large limit with improved asymptotic performance.       | Implement the Sieve of Atkin, which uses quadratic forms and modular arithmetic to identify primes. Although more complex to implement, it offers better asymptotic performance than the traditional Sieve of Eratosthenes for very large n.                                                                                                                             |
| **Sieve of Eratosthenes**                         | Generating all prime numbers up to a given limit efficiently.                                     | Use the classic Sieve of Eratosthenes to iteratively mark multiples of each prime number in a boolean array, achieving O(n log log n) time complexity. This method is simple, memory-efficient, and widely used in competitive programming.                                                                                                                            |
| **Smallest Prime Factor (SPF) Precomputation**  | Quickly factorizing numbers using precomputed smallest prime factors.                           | Precompute an array of the smallest prime factors for all numbers up to n using a modified sieve. This allows rapid factorization of any number by iteratively dividing by its SPF, which is particularly useful in many number theory challenges.                                                                                                                    |
| **Wheel Factorization**                         | Optimizing trial division for primality testing by skipping multiples of small primes.             | Implement wheel factorization by constructing a "wheel" (often based on primes like 2, 3, and 5) to skip composite numbers during trial division, thereby reducing the number of iterations and speeding up the process.                                                                                                                                                  |