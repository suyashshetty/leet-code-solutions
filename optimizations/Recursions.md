| **Optimization Technique**         | **Scenario**                                                                                     | **Solution/Approach**                                                                                                                                                                                       |
|------------------------------------|---------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Branch and Bound**              | Combinatorial optimization where exploring all possible solutions is infeasible.                 | Compute bounds for partial solutions and prune branches that cannot yield a better solution than the best known, reducing the overall search space significantly.                                           |
| **Constraint Propagation**         | Problems with well-defined constraints (e.g., puzzles, scheduling) that allow early elimination of options. | Propagate constraints through recursive calls to eliminate impossible values from consideration, thereby trimming the recursion tree and speeding up backtracking.                                     |
| **Heuristic Ordering**             | Recursion/backtracking problems where the order of exploring options critically impacts performance. | Order choices so that the most promising options are explored first, leading to early discovery of valid or optimal solutions and enhancing the efficiency of pruning.                                  |
| **Iterative Deepening DFS (IDDFS)**| Problems with deep recursion or unbounded search spaces.                                         | Combine the space efficiency of DFS with the optimality of BFS by gradually increasing the depth limit, ensuring that recursion remains manageable while eventually exploring all paths.                |
| **Memoization**                    | Recursive problems with overlapping subproblems (e.g., Fibonacci sequence, pathfinding).          | Cache results of recursive calls to avoid redundant computations, effectively reducing exponential time complexity to a polynomial scale through dynamic programming techniques.                   |
| **Recursion Elimination / DP**     | Scenarios where recursion incurs excessive overhead or risks stack overflow.                     | Convert recursive algorithms into iterative dynamic programming solutions, thereby reducing function call overhead and often achieving superior time performance.                                      |
| **Recursion Elimination using an Explicit Stack**| Deep recursive problems where system recursion limits may be exceeded or where call overhead is high. | Convert the recursive algorithm into an iterative one by using an explicit stack to mimic the call stack. This method gives you more control over the stack memory, prevents stack overflow, and can sometimes yield better performance by reducing function call overhead.                                                 |
| **State Compression**              | Recursive problems with large state spaces where memory consumption and repeated state comparisons are costly. | Use techniques such as bitmasking to encode states compactly, reducing memory usage and optimizing both comparisons and memoization efforts.                                                               |
| **Tail Recursion Optimization**    | Deep recursive calls that may lead to stack overflow or high call overhead if not optimized.      | Refactor recursive functions into tail-recursive forms that compilers can optimize into iterative loops, mitigating stack overflow risks and reducing overhead associated with function calls.           |
