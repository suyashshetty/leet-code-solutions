| **Optimization Technique**                   | **Scenario**                                                                              | **Solution/Approach**                                                                                                                                                                                                                                                                                                                                                                         |
|----------------------------------------------|--------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **A\* Search Algorithm**                     | Pathfinding in spatial or grid-based graphs where an admissible heuristic is available.       | Incorporate a heuristic (e.g., Manhattan or Euclidean distance) to guide the search toward the target, effectively reducing the number of nodes visited compared to Dijkstra’s algorithm. This approach is particularly beneficial in maze or route-finding problems.                                                                                                                  |
| **ALT (A*, Landmarks, and Triangle Inequality)** | Large-scale routing in road networks or grid-like maps with numerous queries.                  | Precompute distances from a set of strategically chosen landmarks to all nodes. Use these distances to enhance the A* heuristic, leading to faster convergence on the optimal path. This method can substantially speed up queries on very large graphs.                                                                                                                               |
| **Bellman-Ford Algorithm**                   | Graphs with negative edge weights, and the need to detect negative cycles.                  | Relax all edges repeatedly over V–1 iterations, then check for changes in a final pass to detect negative cycles. Works in O(V·E) time and is useful when negative weights are present.                                                                                                                                                                                               |
| **Bidirectional Dijkstra**                   | Point-to-point shortest path queries in large graphs.                                       | Run Dijkstra’s algorithm simultaneously from both the source and target nodes. When the search frontiers meet, combine the results to obtain the shortest path, often reducing the explored search space and overall runtime.                                                                                                                                                           |
| **Contraction Hierarchies**                  | Very large road networks or graphs where rapid repeated shortest path queries are required.   | Preprocess the graph by "contracting" nodes and adding shortcut edges, then utilize these shortcuts during queries to accelerate the search. This technique is highly effective in scenarios such as mapping applications where many point-to-point queries are performed on a large static graph.                                                                                          |
| **Dijkstra's Algorithm**                     | Single-source shortest path in graphs with non-negative edge weights.                      | Use a min-priority queue to iteratively relax the closest unvisited vertex, achieving O((V+E) log V) time complexity. Suitable for many grid and graph problems where weights are non-negative.                                                                                                                                                                                        |
| **Floyd-Warshall Algorithm**                 | All-pairs shortest path in dense graphs or when comprehensive connectivity analysis is required. | Use dynamic programming to update distances between every pair of vertices in O(V³) time. Best suited for graphs with a moderate number of vertices where all-pairs queries are needed.                                                                                                                                                                                                  |
| **Johnson's Algorithm**                      | All-pairs shortest paths in sparse graphs with negative weights (without negative cycles).    | First, reweight the graph using Bellman-Ford to eliminate negative weights, then run Dijkstra’s algorithm from each vertex. This yields a time complexity of O(V² log V + V·E), which is efficient for sparse graphs requiring all-pairs distances.                                                                                                                                |
| **SPFA (Shortest Path Faster Algorithm)**    | Graphs with negative weights where average-case performance may outperform Bellman-Ford.      | Optimize Bellman-Ford by using a queue to process vertices, which can reduce redundant relaxations in practice, leading to faster average performance while still handling negative edge weights.                                                                                                                                                                                      |

Additional 

| **Optimization Technique**              | **Scenario**                                                                                       | **Solution/Approach**                                                                                                                                                                                                                                                                                                                                                           |
|-----------------------------------------|-----------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **0-1 BFS**                             | Graphs where edge weights are either 0 or 1.                                                        | Use a deque to process nodes: add neighbors reached via 0-weight edges to the front and those via 1-weight edges to the back. This yields an overall time complexity of O(V + E), making it highly efficient for such specialized graphs.                                                                                                                             |
| **Bidirectional A\* Search**             | Point-to-point shortest path queries in large graphs with an effective heuristic available.          | Run A\* search concurrently from both the source and the target nodes using appropriate heuristics. When the search frontiers meet, combine the partial paths to obtain the shortest route, often reducing the search space significantly compared to unidirectional A\*.                                                             |
| **D\* Lite Algorithm**                   | Dynamic environments where graph edge weights change over time (e.g., robot navigation in a changing map). | An incremental search algorithm that reuses previous search efforts, enabling rapid re-planning when the graph changes without recomputing the entire path from scratch.                                                                                                                                                                                                 |
| **Dial's Algorithm**                      | Graphs with non-negative, bounded integer edge weights.                                             | Use an array of buckets to group vertices by their tentative distances. This bucket-based approach can achieve O(V + E) time complexity when the maximum edge weight is small, offering a practical alternative to the traditional priority queue in Dijkstra’s algorithm.                                                                                      |
| **Lifelong Planning A\* (LPA\*)**          | Repeated shortest path queries in dynamic graphs with incremental changes.                           | Maintain and update shortest path information over time. LPA\* reuses previous computations to quickly adjust paths when small changes occur in the graph, avoiding the need to re-run the entire A\* search from scratch.                                                                                                                                           |
| **Radix Heap**                           | Optimizing Dijkstra’s algorithm on graphs with integer edge weights, particularly when weights are small. | Replace the standard binary heap with a radix heap in Dijkstra’s algorithm. This data structure can lead to improved performance (especially on sparse graphs) by exploiting the properties of integer weights to reduce per-operation overhead.                                                                                                               |
| **Yen's Algorithm**                      | Finding the K shortest loopless paths between two nodes in a graph.                                  | Generate the shortest path first and then iteratively compute subsequent paths by introducing deviations from the previous paths. This method enumerates alternative paths in increasing order of length, which is useful in scenarios requiring multiple candidate routes rather than just a single optimal path.                                            |
